import { IntelligibilityLevel, SlavicLanguage } from '../types';
import { IntelligibilityReport } from '../core/IntelligibilityReport';

const BEFORE_PARENTHESES = /^([^(]+)/;

export default function parseSameInLanguages(
  encoded: string,
): IntelligibilityReport {
  const [, beforeParentheses] = BEFORE_PARENTHESES.exec(encoded) || [];

  return parseIntellgibilityFragment(beforeParentheses);
}

function parseIntellgibilityFragment(encoded: string): IntelligibilityReport {
  const result = new IntelligibilityReport();
  if (!encoded) {
    return result;
  }

  const tokens = encoded.split(/\s+/);
  for (const token of tokens) {
    const stripped = token.replace(/[^a-z]/g, '');
    const symbols = token.replace(/[a-z!]/g, '');
    const autogenerated = token.includes('!');

    for (const lang of expandRegionalTag(stripped)) {
      result[lang].level = parseLevel(symbols);
      result[lang].autogenerated = autogenerated;
    }
  }

  return result;
}

function parseLevel(encodedIntelligibility: string): IntelligibilityLevel {
  switch (encodedIntelligibility) {
    case '+':
      return IntelligibilityLevel.DirectMatch;
    case '*':
      return IntelligibilityLevel.HelperMatch;
    case '?':
      return IntelligibilityLevel.AmbiguousDirectMatch;
    case '~':
      return IntelligibilityLevel.AmbiguousHelperMatch;
    case '#':
      return IntelligibilityLevel.FalseFriend;
    case '-':
      return IntelligibilityLevel.NoMatch;
    default:
      return IntelligibilityLevel.Unknown;
  }
}

function expandRegionalTag(tag: string): SlavicLanguage[] {
  const L = SlavicLanguage;

  switch (tag) {
    case 'v': // Eastern Slavic langauges
      return [L.Russian, L.Belarusian, L.Ukrainian, L.Rusyn];
    case 'ru':
      return [L.Russian];
    case 'be':
      return [L.Belarusian];
    case 'uk':
      return [L.Ukrainian];
    case 'rue':
      return [L.Rusyn];
    case 'cu':
      return [L.ChurchSlavonic];
    case 'ub':
      return [L.Ukrainian, L.Belarusian];

    case 'z': // Western Slavic languages
      return [L.Polish, L.Slovak, L.Czech];
    case 'pl':
      return [L.Polish];
    case 'sk':
      return [L.Slovak];
    case 'cz':
      return [L.Czech];
    case 'cs':
      return [L.Czech, L.Slovak];
    case 'csb':
      return [L.Kashubian];
    case 'szl':
      return [L.Silesian];
    case 'dsb':
      return [L.LowerSorbian];
    case 'hsb':
      return [L.UpperSorbian];
    case 'sb':
      return [L.LowerSorbian, L.UpperSorbian];

    case 'j': // Southern Slavic Languages
      return [
        L.Bulgarian,
        L.Macedonian,
        L.Bosnian,
        L.Croatian,
        L.Montenegrin,
        L.Serbian,
        L.Slovenian,
      ];
    case 'bg':
      return [L.Bulgarian];
    case 'mk':
      return [L.Macedonian];
    case 'sr':
      return [L.Serbian];
    case 'hr':
      return [L.Croatian];
    case 'sl':
      return [L.Slovenian];
    case 'bm':
      return [L.Bulgarian, L.Macedonian];
    case 'yu':
      return [L.Slovenian, L.Croatian, L.Serbian, L.Bosnian, L.Montenegrin];
    case 'sh':
      return [L.Serbian, L.Croatian, L.Bosnian, L.Montenegrin];
    default:
      return [];
  }
}
