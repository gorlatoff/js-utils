import { IntelligibilityReport } from './IntelligibilityReport';
import {
  IntelligibilityLevel,
  IntelligibilityLevelDescription,
  SlavicLanguage,
} from '../types';

describe('IntelligibilityReport', () => {
  it.each([
    ['be'],
    ['bg'],
    ['bs'],
    ['cnr'],
    ['cs'],
    ['csb'],
    ['cu'],
    ['dsb'],
    ['hr'],
    ['hsb'],
    ['mk'],
    ['pl'],
    ['ru'],
    ['rue'],
    ['sk'],
    ['sl'],
    ['sr'],
    ['szl'],
    ['uk'],
  ])('should have autogenerated unknown for %s', (rawLang) => {
    const lang = rawLang as SlavicLanguage;
    const report = new IntelligibilityReport();

    expect(report[lang].tag).toBe(lang);
    expect(report[lang].level).toBe('');
    expect(report[lang].autogenerated).toBe(true);
  });

  describe('toString()', () => {
    it('should generate an empty string', () => {
      expect(`${new IntelligibilityReport()}`).toBe('');
    });

    it.each([
      ['!be+', SlavicLanguage.Belarusian, 'DirectMatch', true],
      ['bs*', SlavicLanguage.Bosnian, 'HelperMatch', false],
      ['!bg?', SlavicLanguage.Bulgarian, 'AmbiguousDirectMatch', true],
      ['hr~', SlavicLanguage.Croatian, 'AmbiguousHelperMatch', false],
      ['!cs#', SlavicLanguage.Czech, 'FalseFriend', true],
      ['csb-', SlavicLanguage.Kashubian, 'NoMatch', false],
      ['!dsb+', SlavicLanguage.LowerSorbian, 'DirectMatch', true],
      ['mk*', SlavicLanguage.Macedonian, 'HelperMatch', false],
      ['!cnr?', SlavicLanguage.Montenegrin, 'AmbiguousDirectMatch', true],
      ['cu~', SlavicLanguage.ChurchSlavonic, 'AmbiguousHelperMatch', false],
      ['!pl#', SlavicLanguage.Polish, 'FalseFriend', true],
      ['ru-', SlavicLanguage.Russian, 'NoMatch', false],
      ['!rue+', SlavicLanguage.Rusyn, 'DirectMatch', true],
      ['sr*', SlavicLanguage.Serbian, 'HelperMatch', false],
      ['!szl?', SlavicLanguage.Silesian, 'AmbiguousDirectMatch', true],
      ['sk~', SlavicLanguage.Slovak, 'AmbiguousHelperMatch', false],
      ['!sl#', SlavicLanguage.Slovenian, 'FalseFriend', true],
      ['uk-', SlavicLanguage.Ukrainian, 'NoMatch', false],
      ['!hsb+', SlavicLanguage.UpperSorbian, 'DirectMatch', true],
    ] as [string, SlavicLanguage, IntelligibilityLevelDescription, boolean][])(
      'should generate %s',
      (expected, lang, level, autogenerated) => {
        const report = new IntelligibilityReport();
        report[lang].level = IntelligibilityLevel[level];
        report[lang].autogenerated = autogenerated;
        expect(`${report}`).toBe(expected);
      },
    );
  });

  it('should display multiple tags', () => {
    const report = new IntelligibilityReport();

    report.uk.autogenerated = report.ru.autogenerated = false;
    report.uk.level = IntelligibilityLevel.DirectMatch;
    report.be.level = IntelligibilityLevel.DirectMatch;
    report.ru.level = IntelligibilityLevel.HelperMatch;
    report.pl.level = IntelligibilityLevel.DirectMatch;

    expect(`${report}`).toBe('!be+ !pl+ ru* uk+');
  });
});
